<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  <title>Document</title>
</head>
<body>
  <script type="text/babel">

    // 1. 객체 리터럴 개선은 구조 분해와 반대
    //객체 리터럴 사용 시 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있음

    var name = "최규리"
    var height = 164

    var personInfo = name, height
    console.log(personInfo) //{name: "최규리", height: 164}


    // 2. 객체 리터럴 개선 또는 객체 재구축으로 객체 메서드 만들기

    var name = "최규리"
    var height = 164
    var print = function(){
      console.log(`${this.name}의 키는 ${this.height}cm 입니다.`)
      //객체의 키에 접근하기 위해 this 사용
    }

    var personInfo = {name, height, print}
    personInfo.print() //최규리의 키는 164cm 입니다.


    // 3. 객체 메서드 정의 시 function 키워드 사용 여부에 따른 비교
    //이건 예제가 웃겨서 그대로 써야겠음.

    //예전 방식
    var name = "Léo Taillefer"
    var sound = "Kahh"

    var skier = {
      name: name,
      sound: sound,
      powderYell: function() {
      var yell = this.sound.toUpperCase()
      console.log(`${yell} ${yell} ${yell}!!!`)
    },
      speed: function(mph) {
        this.speed = mph
        console.log('속력(mph):', mph)
      }
    }

    skier.powderYell()
    skier.speed("엉덩이에 불날 것 같은")
    console.log(JSON.stringify(skier))

    //객체 리터럴 개선
    var name = "Julia Mancuso"
    var sound = "go fast"

    const skier = {
      name,
      sound,
      powderYell() {
        let yell = this.sound.toUpperCase()
        console.log(`${yell} ${yell} ${yell}!!!`)
      },
      speed(mph) {
        this.speed = mph
        console.log('속력(mph):', mph)
      }
    }

    skier.powderYell()
    skier.speed(350)
    console.log(JSON.stringify(skier))

</script>
</body>
</html>